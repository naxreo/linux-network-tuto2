<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Linux Network Flow Map</title>
  <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      display: flex;
      height: 100vh;
      background: #0a0a0a;
      color: #e5e5e5;
      overflow: hidden;
    }

    #cy {
      flex: 1;
      background: #111;
      position: relative;
    }

    #info {
      width: 350px;
      padding: 20px;
      background: #1a1a1a;
      border-left: 1px solid #333;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    #info h3 {
      margin: 0 0 8px 0;
      color: #7dd3fc;
      font-size: 18px;
      border-bottom: 2px solid #2563eb;
      padding-bottom: 8px;
    }

    #info p {
      margin: 8px 0;
      line-height: 1.6;
      color: #d1d5db;
    }

    #info .desc {
      color: #9ca3af;
      font-size: 14px;
    }

    #info .function-list {
      margin-top: 12px;
      padding-left: 20px;
    }

    #info .function-list li {
      margin: 6px 0;
      color: #60a5fa;
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }

    #info .level-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      margin-right: 8px;
    }

    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(26, 26, 26, 0.9);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #333;
      z-index: 1000;
    }

    #controls h4 {
      margin: 0 0 8px 0;
      color: #7dd3fc;
      font-size: 14px;
    }

    #controls .control-item {
      margin: 4px 0;
      font-size: 12px;
      color: #9ca3af;
    }

    #zoom-level {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(26, 26, 26, 0.9);
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #333;
      z-index: 1000;
      font-size: 12px;
      color: #60a5fa;
    }

    .legend {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #333;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 8px 0;
      font-size: 12px;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      margin-right: 8px;
    }

    .group-label {
      position: absolute;
      font-size: 24px;
      font-weight: bold;
      color: #60a5fa;
      z-index: 1000;
      pointer-events: none;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    #rx-label {
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
    }

    #tx-label {
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
    }
  </style>
</head>
<body>

<div id="cy"></div>

<div id="info">
  <h3>Node Info</h3>
  <p class="desc">노드를 클릭하여 상세 정보를 확인하세요.</p>
  <p class="desc">마우스 휠로 확대/축소, 드래그로 이동할 수 있습니다.</p>
</div>

<div id="controls">
  <h4>Controls</h4>
  <div class="control-item">🖱️ 드래그: 이동</div>
  <div class="control-item">🖱️ 휠: 확대/축소</div>
  <div class="control-item">⌨️ 방향키: 이동</div>
  <div class="control-item">⌨️ +/-: 확대/축소</div>
  <div class="control-item">⌨️ ESC: 전체 보기</div>
</div>

<div id="zoom-level">Zoom: 1.00x</div>

<div id="rx-label" class="group-label">RX (Receive Path)</div>
<div id="tx-label" class="group-label">TX (Transmit Path)</div>

<script>
// Zoom 레벨 정의
const ZOOM_LEVEL = {
  OVERVIEW: 0.5,
  HOOK: 1.2,
  TABLE: 1.8,
  FUNCTION: 2.5
};

// 계층별 색상 정의
const LEVEL_COLORS = {
  HARDWARE: '#ef4444',      // NIC - 빨간색
  DRIVER: '#f97316',        // Driver - 주황색
  KERNEL_LOW: '#eab308',    // NAPI, skb - 노란색
  NETFILTER: '#8b5cf6',     // Netfilter - 보라색
  ROUTING: '#06b6d4',       // Routing - 청록색
  SOCKET: '#10b981',        // Socket - 초록색
  XDP: '#ec4899',           // XDP - 핑크색
  TC: '#6366f1',            // TC/qdisc - 인디고색
  BUFFER: '#14b8a6',        // Buffer - 틸색
  USER: '#f59e0b',          // User-space - 앰버색
  KERNEL_OPTION: '#a855f7', // Kernel Option - 보라색
  DROP: '#dc2626',          // Packet Drop - 진한 빨간색
  RST: '#991b1b'            // RST - 어두운 빨간색
};

// 노드 데이터 구조
const networkData = {
  nodes: [
    // RX 경로
    { 
      id: 'nic-rx', 
      label: 'NIC', 
      level: 'HARDWARE', 
      desc: '네트워크 인터페이스 카드',
      detailedDesc: '물리적 네트워크 인터페이스 카드로, 전기 신호를 받아 패킷을 수신합니다. 패킷이 도착하면 DMA(Direct Memory Access)를 통해 커널 메모리의 ring buffer에 패킷을 직접 적재하고, 하드웨어 인터럽트를 발생시켜 커널에 패킷 수신을 알립니다.',
      functions: ['interrupt handler'], 
      position: { x: 0, y: -250 } 
    },
    { 
      id: 'nic-rx-ring', 
      label: 'NIC RX Ring', 
      level: 'BUFFER', 
      desc: 'NIC 수신 링 버퍼',
      detailedDesc: 'NIC 하드웨어가 패킷을 수신할 때 DMA를 통해 커널 메모리에 직접 적재하는 링 버퍼입니다. 드라이버가 미리 할당한 메모리 영역으로, 하드웨어가 직접 접근할 수 있습니다. 패킷이 도착하면 이 버퍼에 저장되고, 드라이버가 이를 읽어서 처리합니다. 링 버퍼는 순환 구조로 되어 있어 고속 패킷 처리가 가능합니다.',
      functions: ['DMA', 'ring buffer descriptor'], 
      position: { x: 150, y: -200 } 
    },
    { 
      id: 'driver-rx', 
      label: 'Driver', 
      level: 'DRIVER', 
      desc: '네트워크 카드 드라이버',
      detailedDesc: 'NIC 하드웨어와 커널 네트워크 스택을 연결하는 드라이버입니다. 인터럽트 핸들러에서 패킷 수신을 감지하면, NAPI(New API) 스케줄링을 통해 인터럽트 기반 처리를 폴링 기반으로 전환합니다. 이는 고속 네트워크에서 인터럽트 폭주를 방지하기 위한 메커니즘입니다.',
      functions: ['napi_schedule()', 'driver_poll()'], 
      position: { x: 300, y: -250 } 
    },
    { 
      id: 'xdp-rx', 
      label: 'XDP', 
      level: 'XDP', 
      desc: 'eBPF 기반 드라이버 레벨 처리 (옵션)',
      detailedDesc: 'XDP(eXpress Data Path)는 eBPF 프로그램을 사용하여 드라이버 레벨에서 매우 빠른 패킷 처리를 가능하게 합니다. skb 생성 이전 또는 직후에 실행되며, Netfilter보다 먼저 처리됩니다. DROP(패킷 폐기), PASS(통과), TX(재전송), REDIRECT(다른 인터페이스로 리다이렉트) 등의 액션을 수행할 수 있습니다. DDoS 방어, 로드 밸런싱, 패킷 필터링 등에 사용됩니다.',
      functions: ['bpf_prog_run_xdp()', 'xdp_do_redirect()'], 
      position: { x: 450, y: -150 } 
    },
    { 
      id: 'napi-rx', 
      label: 'NAPI', 
      level: 'KERNEL_LOW', 
      desc: '인터럽트 → 폴링 전환',
      detailedDesc: 'NAPI(New API)는 고속 네트워크 환경에서 인터럽트 폭주를 방지하기 위한 메커니즘입니다. 초기 인터럽트 후에는 폴링 모드로 전환되어 여러 패킷을 한 번에 처리합니다. 이는 CPU 효율성을 크게 향상시킵니다. struct napi_struct 구조체로 관리되며, GRO(Generic Receive Offload)와 함께 작동하여 패킷을 효율적으로 처리합니다.',
      functions: ['napi_poll()', 'napi_gro_receive()'], 
      position: { x: 600, y: -250 } 
    },
    { 
      id: 'skb-rx', 
      label: 'sk_buff', 
      level: 'KERNEL_LOW', 
      desc: '패킷 메타데이터 구조체',
      detailedDesc: 'sk_buff(socket buffer)는 리눅스 커널에서 모든 네트워크 패킷을 표현하는 핵심 데이터 구조입니다. 패킷 데이터와 메타데이터(프로토콜, 길이, 네트워크 인터페이스, 라우팅 정보 등)를 포함합니다. 이 구조체는 네트워크 스택 전체를 통과하며, 각 계층에서 필요한 정보를 추가하거나 수정합니다. 주요 필드로는 skb->data(패킷 데이터), skb->len(길이), skb->protocol(프로토콜), skb->dev(네트워크 장치) 등이 있습니다.',
      functions: ['build_skb()', 'netif_receive_skb()'], 
      position: { x: 900, y: -250 } 
    },
    { 
      id: 'netfilter-rx', 
      label: 'Netfilter', 
      level: 'NETFILTER', 
      desc: '패킷 필터링 및 NAT',
      detailedDesc: 'Netfilter는 리눅스 커널의 패킷 필터링 및 NAT(Network Address Translation) 프레임워크입니다. iptables와 nftables의 기반이 되는 인프라로, 여러 hook 지점에서 패킷을 가로채 처리합니다. PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING의 5가지 hook 지점에서 패킷을 검사하고, conntrack(연결 추적), NAT, 필터링, mangling 등의 작업을 수행합니다.\n\n동작 방식:\n1. 패킷이 네트워크 스택을 통과할 때 각 hook 지점에서 등록된 규칙들을 순차적으로 검사합니다.\n2. 각 규칙은 ACCEPT(통과), DROP(폐기), REJECT(거부), NAT(주소 변환) 등의 액션을 수행할 수 있습니다.\n3. conntrack은 연결 상태를 추적하여 상태 기반 방화벽을 가능하게 합니다.\n4. NAT는 PREROUTING(DNAT), POSTROUTING(SNAT)에서 주로 수행됩니다.\n5. iptables는 이 hook들에 규칙을 등록하는 사용자 공간 도구입니다.',
      functions: ['nf_hook_slow()'], 
      position: { x: 1200, y: -250 } 
    },
    { 
      id: 'routing-rx', 
      label: 'Routing', 
      level: 'ROUTING', 
      desc: '라우팅 테이블 조회',
      detailedDesc: '라우팅 결정 단계에서는 FIB(Forwarding Information Base)를 조회하여 패킷의 목적지가 로컬 시스템인지, 다른 호스트로 포워딩해야 하는지 결정합니다. ip_route_input_noref() 함수가 라우팅 테이블을 조회하고, 결과에 따라 로컬 수신(INPUT) 또는 포워딩(FORWARD) 경로로 분기합니다. 라우팅 결정 후에는 패킷의 목적지 인터페이스와 게이트웨이 정보가 skb에 설정됩니다.',
      functions: ['ip_route_input_noref()', 'ip_rcv_finish()'], 
      position: { x: 1500, y: -250 } 
    },
    { 
      id: 'socket-rx', 
      label: 'Socket', 
      level: 'SOCKET', 
      desc: 'User-space 전달',
      detailedDesc: 'Socket은 커널과 사용자 공간 애플리케이션 사이의 인터페이스 역할을 하는 추상화 계층입니다. Socket 계층에서는 L4(전송 계층) 프로토콜(TCP/UDP/SCTP 등)에 따라 패킷을 처리합니다. TCP의 경우 tcp_v4_rcv()에서 패킷의 시퀀스 번호, 체크섬, 연결 상태를 검증하고, ESTABLISHED 상태의 연결에 대해서는 tcp_v4_do_rcv()를 호출하여 처리합니다. 패킷이 올바르게 처리되면 sock_queue_rcv_skb()를 통해 해당 소켓의 수신 큐(sk_receive_queue)에 추가됩니다. 패킷이 큐에 추가되면 sk_data_ready() 콜백을 호출하여 대기 중인 사용자 공간 프로세스를 깨웁니다(wakeup). Socket은 struct socket과 struct sock 구조체로 표현되며, 각 소켓은 고유한 파일 디스크립터와 연결됩니다. 사용자 공간의 recv(), read(), recvfrom() 등의 시스템 콜은 이 큐에서 데이터를 읽어갑니다. Socket은 또한 프로토콜별 특성(TCP의 신뢰성, 순서 보장, 흐름 제어, UDP의 비연결성 등)을 구현합니다.',
      functions: ['tcp_v4_rcv()', 'tcp_v4_do_rcv()', 'sock_queue_rcv_skb()', 'sk_data_ready()', 'inet_recvmsg()'], 
      position: { x: 1800, y: -250 } 
    },
    { 
      id: 'tcp-rx-buffer', 
      label: 'TCP RX Buffer', 
      level: 'BUFFER', 
      desc: 'TCP 수신 버퍼',
      detailedDesc: 'TCP 수신 버퍼는 TCP 프로토콜이 수신한 데이터를 저장하는 버퍼입니다. 순서가 맞지 않은 패킷을 재정렬하거나, 애플리케이션이 읽을 때까지 데이터를 보관합니다. 이 버퍼의 크기는 SO_RCVBUF 소켓 옵션으로 설정할 수 있으며, TCP 흐름 제어와 혼잡 제어에 중요한 역할을 합니다.',
      functions: ['tcp_rcv_established()', 'tcp_data_queue()'], 
      position: { x: 1800, y: -200 } 
    },
    { 
      id: 'socket-rx-queue', 
      label: 'Socket RX Queue', 
      level: 'BUFFER', 
      desc: '소켓 수신 큐',
      detailedDesc: '소켓의 수신 큐(sk_receive_queue)는 커널에서 사용자 공간으로 전달될 패킷을 저장하는 큐입니다. TCP/UDP 등 프로토콜 계층에서 처리된 패킷이 이 큐에 추가되고, 사용자 공간의 recv(), read() 등의 시스템 콜이 이 큐에서 데이터를 읽어갑니다. 큐가 비어있으면 프로세스가 블로킹되고, 데이터가 도착하면 wakeup 신호를 받아 깨어납니다.',
      functions: ['sock_queue_rcv_skb()', 'skb_queue_tail()', 'sk_data_ready()'], 
      position: { x: 1950, y: -250 } 
    },
    { 
      id: 'user-rx', 
      label: 'User Application', 
      level: 'USER', 
      desc: '사용자 공간 애플리케이션 (RX)',
      detailedDesc: '사용자 공간 애플리케이션이 recv(), read(), recvfrom() 등의 시스템 콜을 호출하여 소켓에서 데이터를 수신합니다. 커널의 소켓 수신 큐에서 데이터를 읽어와 애플리케이션 버퍼로 복사합니다. 큐가 비어있으면 프로세스가 블로킹되고, 데이터가 도착하면 wakeup 신호를 받아 깨어나 데이터를 읽어갑니다.',
      functions: ['recv()', 'read()', 'recvfrom()'], 
      position: { x: 2100, y: -250 } 
    },
    
    // Netfilter Hook 세부
    { 
      id: 'nf:prerouting', 
      label: 'PREROUTING', 
      level: 'NETFILTER', 
      desc: '라우팅 전 처리',
      detailedDesc: 'PREROUTING hook은 라우팅 결정 이전에 실행되는 첫 번째 Netfilter hook입니다. 여기서 주로 DNAT(Destination NAT)와 conntrack(연결 추적)이 시작됩니다. 패킷의 목적지 주소를 변경하거나, 연결 추적 테이블에 연결 정보를 기록합니다. 이 hook은 모든 들어오는 패킷에 대해 실행되며, NF_INET_PRE_ROUTING hook point에서 처리됩니다.\n\n역할:\n- DNAT(Destination NAT): 패킷의 목적지 IP 주소를 변경합니다. 예를 들어, 외부에서 들어온 패킷의 목적지를 내부 서버로 변경할 수 있습니다.\n- 연결 추적 시작: conntrack이 패킷을 분석하여 연결 상태를 추적하기 시작합니다.\n- 패킷 mangling: TOS(Type of Service) 필드 변경 등 패킷 헤더 수정이 가능합니다.\n\n동작 방식:\n1. 패킷이 NIC에서 들어와 IP 계층에 도달한 직후 실행됩니다.\n2. 라우팅 결정 전이므로 목적지 주소를 변경할 수 있습니다.\n3. iptables의 PREROUTING 체인 규칙이 여기서 실행됩니다.\n4. DNAT 규칙이 적용되면 패킷의 목적지 IP가 변경되고, 이후 라우팅 결정에 영향을 줍니다.\n5. conntrack은 패킷을 분석하여 연결 상태(ESTABLISHED, NEW, RELATED 등)를 결정합니다.',
      functions: ['nf_hook_slow()', 'ipv4_conntrack_in()'], 
      parent: 'netfilter-rx', 
      position: { x: 1200, y: -350 } 
    },
    { 
      id: 'nf:input', 
      label: 'INPUT', 
      level: 'NETFILTER', 
      desc: '로컬 목적지 처리',
      detailedDesc: 'INPUT hook은 로컬 시스템으로 향하는 패킷에 대해서만 실행됩니다. 라우팅 결정 후 패킷의 목적지가 로컬인 경우, 이 hook에서 패킷 필터링 규칙을 적용합니다. 방화벽 규칙, 로깅, 패킷 드롭 등의 작업이 여기서 수행됩니다. NF_INET_LOCAL_IN hook point에서 처리되며, ip_local_deliver() 함수가 이 hook을 호출합니다.\n\n역할:\n- 로컬 수신 패킷 필터링: 로컬 시스템으로 들어오는 패킷에 대한 방화벽 규칙을 적용합니다.\n- 보안 정책 적용: 허용되지 않은 패킷을 DROP하거나 REJECT합니다.\n- 로깅: 패킷을 로그에 기록하여 보안 감사나 디버깅에 사용합니다.\n- 연결 추적 활용: conntrack의 연결 상태를 기반으로 상태 기반 방화벽 규칙을 적용할 수 있습니다.\n\n동작 방식:\n1. 라우팅 결정 후 패킷의 목적지가 로컬 시스템인 경우에만 실행됩니다.\n2. iptables의 INPUT 체인 규칙이 순차적으로 검사됩니다.\n3. 규칙이 매칭되면 해당 액션(ACCEPT, DROP, REJECT 등)이 수행됩니다.\n4. ACCEPT되면 패킷은 상위 계층(TCP/UDP)으로 전달됩니다.\n5. DROP되면 패킷이 조용히 폐기되고, REJECT되면 ICMP 에러 패킷이 전송됩니다.\n6. 상태 기반 규칙(-m state, -m conntrack)을 사용하면 ESTABLISHED 연결의 응답 패킷을 자동으로 허용할 수 있습니다.',
      functions: ['ip_local_deliver()', 'nf_hook()'], 
      parent: 'netfilter-rx', 
      position: { x: 1350, y: -350 } 
    },
    { 
      id: 'nf:forward', 
      label: 'FORWARD', 
      level: 'NETFILTER', 
      desc: '포워딩 처리',
      detailedDesc: 'FORWARD hook은 라우터 역할을 하는 시스템에서, 한 인터페이스로 들어온 패킷을 다른 인터페이스로 전달할 때 실행됩니다. 로컬 시스템이 목적지가 아닌 패킷에 대해 포워딩 규칙을 적용합니다. 이 hook에서도 패킷 필터링, 로깅 등이 수행됩니다. NF_INET_FORWARD hook point에서 처리되며, ip_forward() 함수가 이 hook을 호출합니다.\n\n역할:\n- 라우터 패킷 필터링: 한 네트워크에서 다른 네트워크로 전달되는 패킷에 대한 방화벽 규칙을 적용합니다.\n- 네트워크 간 보안 정책: 내부 네트워크와 외부 네트워크 간 트래픽을 제어합니다.\n- 포워딩 제어: 특정 패킷의 포워딩을 허용하거나 차단할 수 있습니다.\n\n동작 방식:\n1. 라우팅 결정 후 패킷의 목적지가 다른 호스트인 경우에만 실행됩니다.\n2. ip_forward = 1로 설정되어 있어야 포워딩이 가능합니다.\n3. iptables의 FORWARD 체인 규칙이 순차적으로 검사됩니다.\n4. ACCEPT되면 패킷이 출력 인터페이스로 전달됩니다.\n5. DROP되면 패킷이 폐기되어 전달되지 않습니다.\n6. NAT와 함께 사용하면 포트 포워딩이나 라우터의 방화벽 역할을 수행할 수 있습니다.\n7. 일반적으로 로컬 시스템이 라우터나 게이트웨이 역할을 할 때 사용됩니다.',
      functions: ['ip_forward()', 'nf_hook()'], 
      parent: 'netfilter-rx', 
      position: { x: 1200, y: -150 } 
    },
    
    // TX 경로
    { 
      id: 'user-tx', 
      label: 'User Application', 
      level: 'USER', 
      desc: '사용자 공간 애플리케이션 (TX)',
      detailedDesc: '사용자 공간 애플리케이션이 send(), sendto(), write() 등의 시스템 콜을 호출하여 네트워크로 데이터를 전송합니다. 애플리케이션 버퍼의 데이터가 커널 공간으로 복사되고, 소켓의 송신 큐에 추가됩니다. 큐가 가득 차면 프로세스가 블로킹될 수 있습니다.',
      functions: ['send()', 'sendto()', 'write()'], 
      position: { x: -300, y: 250 } 
    },
    { 
      id: 'socket-tx-queue', 
      label: 'Socket TX Queue', 
      level: 'BUFFER', 
      desc: '소켓 송신 큐',
      detailedDesc: '소켓의 송신 큐(sk_write_queue)는 사용자 공간에서 전송 요청된 데이터를 저장하는 큐입니다. send(), sendto() 등의 시스템 콜로 전달된 데이터가 이 큐에 추가되고, TCP/IP 계층에서 순차적으로 처리됩니다. 큐가 가득 차면 프로세스가 블로킹될 수 있습니다.',
      functions: ['sock_alloc_send_skb()', 'skb_queue_tail()'], 
      position: { x: -150, y: 250 } 
    },
    { 
      id: 'socket-tx', 
      label: 'Socket', 
      level: 'SOCKET', 
      desc: 'User-space에서 전송',
      detailedDesc: 'Socket은 사용자 공간 애플리케이션과 커널 네트워크 스택 사이의 인터페이스입니다. 사용자 공간에서 send(), sendto(), write() 등의 시스템 콜을 호출하면, 커널의 syscall 핸들러(__sys_sendto(), __sys_sendmsg() 등)가 호출됩니다. 이 함수들은 sock_sendmsg()를 통해 소켓에 데이터를 전달합니다. 이 시점에서 사용자 공간의 데이터 버퍼가 커널 공간으로 복사되고(또는 zero-copy 기법 사용 시 페이지 참조만 전달), 소켓의 전송 큐(sk_write_queue)에 추가됩니다. Socket은 프로토콜별 특성을 구현합니다: TCP의 경우 tcp_sendmsg()에서 세그먼트 분할, 시퀀스 번호 할당, 흐름 제어 및 혼잡 제어를 수행하고, UDP의 경우 udp_sendmsg()에서 단순히 UDP 헤더를 추가합니다. Socket은 또한 소켓 옵션(SO_SNDBUF, SO_RCVBUF, SO_REUSEADDR 등)을 관리하고, 논블로킹 모드, 타임아웃, 에러 처리 등을 담당합니다. Socket은 struct socket과 struct sock 구조체로 표현되며, 파일 시스템과 통합되어 파일 디스크립터를 통해 접근됩니다.',
      functions: ['__sys_sendto()', '__sys_sendmsg()', 'sock_sendmsg()', 'inet_sendmsg()', 'tcp_sendmsg()', 'udp_sendmsg()'], 
      position: { x: 0, y: 250 } 
    },
    { 
      id: 'tcp-tx', 
      label: 'TCP/IP', 
      level: 'SOCKET', 
      desc: 'TCP/IP 처리',
      detailedDesc: 'TCP 계층에서는 tcp_sendmsg()가 호출되어 데이터를 TCP 세그먼트로 분할합니다. TCP 헤더를 추가하고, 흐름 제어, 혼잡 제어 알고리즘을 적용합니다. 그 후 IP 계층으로 전달하기 위해 ip_queue_xmit()을 호출합니다. 여기서 IP 헤더가 추가되고, 필요시 IP fragmentation이 수행됩니다.',
      functions: ['tcp_sendmsg()', 'tcp_push()', 'ip_queue_xmit()'], 
      position: { x: 300, y: 250 } 
    },
    { 
      id: 'tcp-tx-buffer', 
      label: 'TCP TX Buffer', 
      level: 'BUFFER', 
      desc: 'TCP 송신 버퍼',
      detailedDesc: 'TCP 송신 버퍼는 TCP 프로토콜이 전송할 데이터를 저장하는 버퍼입니다. 애플리케이션에서 전송 요청한 데이터가 이 버퍼에 저장되고, TCP 흐름 제어와 혼잡 제어 알고리즘에 따라 세그먼트로 분할되어 전송됩니다. 이 버퍼의 크기는 SO_SNDBUF 소켓 옵션으로 설정할 수 있으며, 버퍼가 가득 차면 애플리케이션이 블로킹됩니다.',
      functions: ['tcp_sendmsg()', 'tcp_write_xmit()'], 
      position: { x: 300, y: 300 } 
    },
    { 
      id: 'netfilter-tx-out', 
      label: 'Netfilter OUTPUT', 
      level: 'NETFILTER', 
      desc: '출력 전 필터링',
      detailedDesc: 'OUTPUT hook은 로컬 시스템에서 생성된 패킷이 네트워크로 나가기 전에 실행됩니다. 여기서 SNAT(Source NAT)의 일부와 방화벽 규칙이 적용됩니다. 로컬에서 생성된 패킷에 대한 필터링과 NAT 변환이 수행됩니다. NF_INET_LOCAL_OUT hook point에서 처리되며, ip_local_out() 함수가 이 hook을 호출합니다.\n\n역할:\n- 로컬 송신 패킷 필터링: 로컬 시스템에서 나가는 패킷에 대한 방화벽 규칙을 적용합니다.\n- 송신 보안 정책: 특정 목적지나 포트로의 연결을 차단할 수 있습니다.\n- SNAT 초기 단계: 일부 SNAT 작업이 여기서 수행될 수 있습니다.\n- 로깅: 나가는 패킷을 로그에 기록합니다.\n\n동작 방식:\n1. 로컬 애플리케이션이 패킷을 생성하여 네트워크 스택으로 전달한 후, 라우팅 결정 전에 실행됩니다.\n2. iptables의 OUTPUT 체인 규칙이 순차적으로 검사됩니다.\n3. 규칙이 매칭되면 해당 액션(ACCEPT, DROP, REJECT 등)이 수행됩니다.\n4. ACCEPT되면 패킷은 라우팅 결정을 거쳐 POSTROUTING으로 전달됩니다.\n5. DROP되면 패킷이 폐기되어 전송되지 않습니다.\n6. 상태 기반 규칙을 사용하면 ESTABLISHED 연결의 응답 패킷을 자동으로 허용할 수 있습니다.\n7. 예를 들어, 특정 웹사이트로의 접근을 차단하거나, 특정 포트로의 연결을 제한할 수 있습니다.',
      functions: ['nf_hook()', 'ipv4_conntrack_local()', 'ip_local_out()'], 
      position: { x: 600, y: 250 } 
    },
    { 
      id: 'routing-tx', 
      label: 'Routing', 
      level: 'ROUTING', 
      desc: '출력 라우팅',
      detailedDesc: '출력 라우팅에서는 ip_route_output_flow() 함수가 호출되어 패킷의 목적지에 대한 최적의 경로를 결정합니다. 라우팅 테이블을 조회하여 다음 홉(next hop) 주소와 출력 인터페이스를 결정합니다. 이 정보는 skb에 저장되어 이후 단계에서 사용됩니다.',
      functions: ['ip_route_output_flow()'], 
      position: { x: 900, y: 250 } 
    },
    { 
      id: 'netfilter-tx-post', 
      label: 'Netfilter POSTROUTING', 
      level: 'NETFILTER', 
      desc: '라우팅 후 처리',
      detailedDesc: 'POSTROUTING hook은 라우팅 결정 후, 패킷이 실제로 네트워크 인터페이스로 전송되기 직전에 실행되는 마지막 Netfilter hook입니다. 여기서 SNAT(Source NAT)의 최종 단계가 수행되고, 패킷의 소스 주소가 변경됩니다. 또한 마지막 방화벽 체크와 패킷 mangling이 수행됩니다. NF_INET_POST_ROUTING hook point에서 처리됩니다.\n\n역할:\n- SNAT(Source NAT): 패킷의 소스 IP 주소를 변경합니다. MASQUERADE는 동적 IP 환경에서 사용되는 SNAT의 특수 형태입니다.\n- 최종 패킷 수정: 라우팅 결정 후이므로 출력 인터페이스를 알 수 있어, 해당 인터페이스의 IP로 소스 주소를 변경할 수 있습니다.\n- 패킷 mangling: TTL(Time To Live) 변경, TOS 필드 수정 등이 가능합니다.\n- 마지막 필터링: 전송 직전 마지막 보안 체크를 수행할 수 있습니다.\n\n동작 방식:\n1. 라우팅 결정이 완료된 후, 출력 인터페이스가 결정된 상태에서 실행됩니다.\n2. iptables의 POSTROUTING 체인 규칙이 순차적으로 검사됩니다.\n3. SNAT 규칙이 적용되면 패킷의 소스 IP 주소가 변경됩니다.\n4. MASQUERADE는 동적 IP 환경에서 자동으로 출력 인터페이스의 IP를 소스로 사용합니다.\n5. NAT 테이블에 연결 정보가 기록되어, 응답 패킷이 올바르게 역변환됩니다.\n6. 패킷이 드라이버로 전달되어 실제 네트워크로 전송됩니다.\n7. 예를 들어, 내부 네트워크(192.168.1.0/24)의 패킷이 외부로 나갈 때 소스 IP를 공인 IP로 변경하는 것이 여기서 수행됩니다.',
      functions: ['nf_hook()', 'ip_finish_output()'], 
      position: { x: 1200, y: 250 } 
    },
    { 
      id: 'tc-tx', 
      label: 'qdisc / TC', 
      level: 'TC', 
      desc: '트래픽 제어',
      detailedDesc: 'qdisc(Queueing Discipline)와 TC(Traffic Control)는 패킷 전송을 제어하는 메커니즘입니다. dev_queue_xmit() 함수가 호출되면, 네트워크 인터페이스에 연결된 qdisc가 패킷을 큐에 추가하거나 즉시 전송합니다. 다양한 qdisc 알고리즘(fq, cake, pfifo_fast 등)이 사용될 수 있으며, 트래픽 shaping(대역폭 제한), policing(트래픽 제한), 스케줄링 등을 수행합니다. eBPF TC hook도 여기서 실행되어 커스텀 패킷 처리가 가능합니다.',
      functions: ['dev_queue_xmit()', 'qdisc_run()', 'tc_classify()'], 
      position: { x: 1500, y: 250 } 
    },
    { 
      id: 'qdisc-queue', 
      label: 'qdisc Queue', 
      level: 'BUFFER', 
      desc: 'qdisc 큐',
      detailedDesc: 'qdisc 큐는 트래픽 제어를 위해 패킷을 임시로 저장하는 큐입니다. dev_queue_xmit()에서 패킷이 도착하면, 설정된 qdisc 알고리즘에 따라 패킷이 큐에 추가되거나 즉시 전송됩니다. 큐의 크기와 동작 방식은 qdisc 타입에 따라 다릅니다. pfifo_fast는 단순 FIFO, fq는 공정 큐잉, cake는 고급 트래픽 제어를 제공합니다. 큐가 가득 차면 패킷이 드롭될 수 있습니다.',
      functions: ['qdisc_enqueue()', 'qdisc_dequeue()', 'qdisc_run()'], 
      position: { x: 1500, y: 300 } 
    },
    { 
      id: 'driver-tx', 
      label: 'Driver', 
      level: 'DRIVER', 
      desc: '드라이버 전송',
      detailedDesc: '드라이버의 ndo_start_xmit() 함수가 호출되어 패킷을 NIC 하드웨어로 전송합니다. 드라이버는 패킷을 하드웨어가 이해할 수 있는 형태로 변환하고, DMA를 통해 NIC의 전송 버퍼에 패킷을 복사합니다. 전송 완료 후에는 하드웨어 인터럽트를 통해 커널에 알립니다.',
      functions: ['ndo_start_xmit()', 'netdev_start_xmit()'], 
      position: { x: 1800, y: 250 } 
    },
    { 
      id: 'nic-tx-ring', 
      label: 'NIC TX Ring', 
      level: 'BUFFER', 
      desc: 'NIC 송신 링 버퍼',
      detailedDesc: 'NIC 하드웨어의 전송 링 버퍼는 드라이버가 전송할 패킷을 저장하는 하드웨어 버퍼입니다. 드라이버가 패킷을 이 버퍼에 DMA로 복사하면, NIC 하드웨어가 자동으로 패킷을 네트워크 케이블로 전송합니다. 링 버퍼는 순환 구조로 되어 있어 연속적인 패킷 전송이 가능합니다. 전송 완료 후 하드웨어 인터럽트를 통해 드라이버에 알립니다.',
      functions: ['DMA', 'ring buffer descriptor'], 
      position: { x: 1950, y: 300 } 
    },
    { 
      id: 'nic-tx', 
      label: 'NIC', 
      level: 'HARDWARE', 
      desc: '네트워크 카드로 전송',
      detailedDesc: 'NIC 하드웨어는 DMA를 통해 커널 메모리에서 패킷 데이터를 읽어와 물리적 네트워크 케이블로 전송합니다. 이는 하드웨어 레벨에서 수행되며, 커널의 개입 없이 직접 메모리에서 데이터를 읽어 전송합니다. 전송 완료 후 하드웨어 인터럽트를 발생시켜 커널에 알립니다.',
      functions: ['DMA'], 
      position: { x: 2100, y: 250 } 
    },
    
    // Netfilter TX Hook 세부
    { 
      id: 'nf:output', 
      label: 'OUTPUT', 
      level: 'NETFILTER', 
      desc: '로컬 생성 패킷 처리',
      detailedDesc: 'OUTPUT hook은 로컬 시스템에서 생성된 패킷에 대해 실행됩니다. 라우팅 결정 전에 실행되며, 로컬에서 생성된 패킷에 대한 필터링과 NAT를 수행합니다. SNAT의 초기 단계가 여기서 수행될 수 있습니다.',
      functions: ['ip_local_out()'], 
      parent: 'netfilter-tx-out', 
      position: { x: 600, y: 350 } 
    },
    { 
      id: 'nf:postrouting', 
      label: 'POSTROUTING', 
      level: 'NETFILTER', 
      desc: '라우팅 후 최종 처리',
      detailedDesc: 'POSTROUTING hook은 라우팅 결정 후, 패킷이 네트워크 인터페이스로 나가기 직전에 실행되는 마지막 hook입니다. SNAT의 최종 단계가 여기서 수행되며, 패킷의 소스 주소가 변경됩니다. 또한 마지막 방화벽 체크와 패킷 mangling이 수행됩니다.',
      functions: ['ip_finish_output()'], 
      parent: 'netfilter-tx-post', 
      position: { x: 1200, y: 350 } 
    },
    
    // 패킷 드롭 및 RST 노드
    { 
      id: 'drop-rx-ring', 
      label: 'Packet Drop', 
      level: 'DROP', 
      desc: 'NIC RX Ring 버퍼 오버플로우',
      detailedDesc: 'NIC RX Ring 버퍼가 가득 찬 경우 패킷이 드롭됩니다.\n\n발생 원인:\n- 고속 네트워크에서 패킷 수신 속도가 드라이버 처리 속도를 초과할 때\n- net.core.netdev_max_backlog 값이 너무 작게 설정된 경우\n- CPU 부하가 높아 패킷 처리가 지연될 때\n- 링 버퍼 크기가 네트워크 트래픽에 비해 부족한 경우\n\n증상:\n- ifconfig에서 RX dropped 카운터 증가\n- 네트워크 성능 저하, 패킷 손실\n- 애플리케이션에서 타임아웃 발생\n\n해결 방법:\n- net.core.netdev_max_backlog 값 증가\n- NIC 링 버퍼 크기 증가 (ethtool -G)\n- CPU 부하 감소, NAPI 효율성 향상',
      functions: ['ring buffer overflow'], 
      position: { x: 150, y: -100 } 
    },
    { 
      id: 'drop-napi', 
      label: 'Packet Drop', 
      level: 'DROP', 
      desc: 'NAPI 백로그 초과',
      detailedDesc: 'NAPI 폴링 중 백로그가 초과되면 패킷이 드롭됩니다.\n\n발생 원인:\n- net.core.netdev_max_backlog 값 초과\n- net.core.netdev_budget 값이 너무 작아 패킷 처리가 완료되지 않을 때\n- 고속 네트워크에서 패킷 도착 속도가 처리 속도를 초과할 때\n\n증상:\n- "netdev_max_backlog exceeded" 커널 메시지\n- 네트워크 인터페이스 통계에서 drop 증가\n- 패킷 손실로 인한 성능 저하\n\n해결 방법:\n- net.core.netdev_max_backlog 값 증가 (기본값: 1000)\n- net.core.netdev_budget 값 조정\n- CPU 성능 향상, 인터럽트 부하 감소',
      functions: ['netif_rx()', 'backlog overflow'], 
      position: { x: 600, y: -100 } 
    },
    { 
      id: 'drop-xdp', 
      label: 'Packet Drop', 
      level: 'DROP', 
      desc: 'XDP DROP 액션',
      detailedDesc: 'XDP 프로그램에서 DROP 액션을 반환하면 패킷이 즉시 폐기됩니다.\n\n발생 원인:\n- XDP eBPF 프로그램이 패킷을 분석한 결과 DROP 액션 반환\n- DDoS 방어, 패킷 필터링 규칙에 의해 차단\n- 잘못 작성된 XDP 프로그램으로 인한 오탐\n\n특징:\n- skb 생성 이전에 드롭되므로 매우 빠름 (마이크로초 단위)\n- Netfilter보다 먼저 실행되어 CPU 부하 절감\n- 드라이버 레벨에서 처리되므로 효율적\n\n사용 사례:\n- DDoS 공격 차단\n- 특정 IP/포트 필터링\n- 로드 밸런싱에서 특정 패킷 제외',
      functions: ['bpf_prog_run_xdp()', 'XDP_DROP'], 
      position: { x: 450, y: -50 } 
    },
    { 
      id: 'drop-netfilter', 
      label: 'Packet Drop', 
      level: 'DROP', 
      desc: 'Netfilter DROP/REJECT',
      detailedDesc: 'iptables/nftables 규칙에서 DROP 또는 REJECT 액션이 적용되면 패킷이 차단됩니다.\n\n발생 원인:\n- iptables INPUT/FORWARD/OUTPUT 체인에서 DROP 규칙 매칭\n- 방화벽 정책에 의해 차단된 패킷\n- REJECT 규칙: 패킷 차단 + ICMP 에러 패킷 전송\n- DROP 규칙: 패킷 조용히 폐기 (에러 패킷 없음)\n\nDROP vs REJECT:\n- DROP: 패킷을 조용히 폐기, 상대방은 타임아웃 대기\n- REJECT: 패킷 폐기 + ICMP destination unreachable 전송, 상대방이 즉시 실패 인지\n\n일반적인 차단 사례:\n- 허용되지 않은 포트로의 연결 시도\n- 차단된 IP 주소에서의 접근\n- 상태 기반 방화벽에서 INVALID 상태의 패킷',
      functions: ['nf_hook_slow()', 'iptables DROP/REJECT'], 
      position: { x: 1200, y: -100 } 
    },
    { 
      id: 'drop-routing', 
      label: 'Packet Drop', 
      level: 'DROP', 
      desc: '라우팅 실패 / TTL 만료',
      detailedDesc: '라우팅 결정 실패 또는 TTL(Time To Live) 만료 시 패킷이 드롭됩니다.\n\n발생 원인:\n- 라우팅 테이블에 목적지 경로가 없는 경우 (No route to host)\n- IP TTL이 0에 도달한 경우 (TTL expired in transit)\n- 목적지 네트워크에 도달할 수 없는 경우\n- Reverse Path Filtering(rp_filter)에 의해 차단된 경우\n\nTTL 만료:\n- IP 헤더의 TTL 필드가 각 라우터를 거칠 때마다 1씩 감소\n- TTL이 0이 되면 패킷 폐기 + ICMP Time Exceeded 메시지 전송\n- 무한 루프 방지, 트레이스라우트에 사용\n\n라우팅 실패:\n- 라우팅 테이블에 경로가 없으면 패킷 폐기\n- ICMP Destination Unreachable (Network Unreachable) 전송\n- ip_forward = 0인 경우 포워딩 불가로 드롭',
      functions: ['ip_route_input_noref()', 'ip_forward()', 'TTL check'], 
      position: { x: 1500, y: -100 } 
    },
    { 
      id: 'drop-tcp', 
      label: 'Packet Drop', 
      level: 'DROP', 
      desc: 'TCP 에러로 인한 드롭',
      detailedDesc: 'TCP 계층에서 패킷 검증 실패 시 패킷이 드롭됩니다.\n\n발생 원인:\n- TCP 체크섬 에러: 패킷이 손상된 경우\n- 시퀀스 번호 범위 밖: 예상 범위를 벗어난 시퀀스 번호\n- TCP 윈도우 오버플로우: 수신 윈도우를 초과하는 데이터\n- 잘못된 TCP 플래그 조합: SYN+FIN, SYN+RST 등 비정상적인 플래그\n- 존재하지 않는 연결로의 패킷: ESTABLISHED 상태가 아닌 연결\n\nTCP 검증 과정:\n1. 체크섬 검증: 패킷 무결성 확인\n2. 시퀀스 번호 검증: 예상 범위 내인지 확인\n3. 연결 상태 확인: 해당 연결이 존재하는지 확인\n4. 윈도우 크기 확인: 수신 가능한 데이터 크기 확인\n\n드롭 시 동작:\n- 패킷은 조용히 폐기됨 (RST 전송 없음)\n- 상대방은 재전송을 시도\n- 일정 횟수 재전송 실패 시 연결 타임아웃',
      functions: ['tcp_v4_rcv()', 'tcp_validate_incoming()', 'tcp_checksum_complete()'], 
      position: { x: 1800, y: -100 } 
    },
    { 
      id: 'rst-tcp', 
      label: 'TCP RST', 
      level: 'RST', 
      desc: 'TCP RST 전송',
      detailedDesc: 'TCP 연결이 비정상적으로 종료되거나 거부될 때 RST(Reset) 패킷이 전송됩니다.\n\n발생 원인:\n- 존재하지 않는 포트로의 연결 시도: 애플리케이션이 해당 포트에서 리스닝하지 않음\n- 연결 상태 불일치: CLOSED 상태의 소켓으로 패킷 수신\n- 애플리케이션 강제 종료: close() 호출 또는 프로세스 종료\n- 타임아웃: 연결 타임아웃 발생\n- 보안 정책: 방화벽이나 애플리케이션이 연결 거부\n\nRST 패킷 특징:\n- TCP 헤더의 RST 플래그가 1로 설정됨\n- 연결을 즉시 종료, 재사용 불가\n- SYN 패킷에 대한 RST: 포트가 닫혀있음을 의미\n- ESTABLISHED 연결에 대한 RST: 연결 강제 종료\n\n일반적인 시나리오:\n1. 클라이언트가 존재하지 않는 포트로 SYN 전송 → 서버가 RST 응답\n2. 타임아웃된 연결로 패킷 수신 → RST 전송\n3. 애플리케이션이 소켓을 닫은 후 패킷 수신 → RST 전송\n\nRST vs FIN:\n- FIN: 정상적인 연결 종료 (4-way handshake)\n- RST: 비정상적인 연결 종료 (즉시 종료)',
      functions: ['tcp_send_active_reset()', 'tcp_reset()', 'inet_csk_reqsk_queue_drop()'], 
      position: { x: 1800, y: -50 } 
    },
    { 
      id: 'drop-qdisc', 
      label: 'Packet Drop', 
      level: 'DROP', 
      desc: 'qdisc 큐 오버플로우',
      detailedDesc: 'qdisc 큐가 가득 차면 패킷이 드롭됩니다.\n\n발생 원인:\n- qdisc 큐 크기 초과: 설정된 큐 크기를 넘는 트래픽\n- 트래픽 shaping 정책: 대역폭 제한으로 인한 큐 포화\n- CPU 부하: 패킷 전송 속도가 큐 비우기 속도보다 빠를 때\n- qdisc 알고리즘에 따른 드롭: RED, CoDel 등은 의도적으로 패킷 드롭\n\nqdisc별 드롭 동작:\n- pfifo_fast: 큐가 가득 차면 tail drop\n- fq (Fair Queue): 각 flow별 큐가 가득 차면 드롭\n- cake: 대역폭 제한 초과 시 드롭\n- RED: 평균 큐 길이가 임계값 초과 시 확률적 드롭\n\n증상:\n- 네트워크 인터페이스 통계에서 TX dropped 증가\n- 대역폭 제한으로 인한 전송 속도 저하\n- 큐 지연 증가\n\n해결 방법:\n- qdisc 큐 크기 증가\n- 트래픽 shaping 정책 조정\n- CPU 부하 감소, 전송 처리 속도 향상',
      functions: ['qdisc_enqueue()', 'qdisc_drop()'], 
      position: { x: 1500, y: 200 } 
    },
    
    // 커널 옵션 노드 (RX와 TX 사이에 배치)
    { 
      id: 'opt-net', 
      label: 'CONFIG_NET', 
      level: 'KERNEL_OPTION', 
      desc: '네트워크 지원',
      detailedDesc: '리눅스 커널의 기본 네트워크 지원을 활성화합니다. 이 옵션이 비활성화되면 네트워크 기능이 완전히 제거됩니다. 모든 네트워크 관련 기능의 기본 전제 조건입니다.\n\n관련 sysctl: net.core.* (모든 네트워크 관련 sysctl의 기반)\n주요 sysctl 및 Ubuntu 24.04 기본값:\n- net.core.rmem_default = 212992 (수신 버퍼 기본 크기)\n- net.core.wmem_default = 212992 (송신 버퍼 기본 크기)\n- net.core.rmem_max = 212992 (수신 버퍼 최대 크기)\n- net.core.wmem_max = 212992 (송신 버퍼 최대 크기)\n- net.core.netdev_max_backlog = 1000 (네트워크 장치 백로그 최대값)\n\n값 변경 시 발생할 수 있는 사례:\n- net.core.netdev_max_backlog를 너무 작게 설정(예: 100): 고속 네트워크에서 패킷 드롭 발생, 네트워크 성능 저하\n- net.core.rmem_max를 너무 작게 설정: TCP 수신 버퍼가 부족하여 대역폭 활용도 감소, 특히 고속 네트워크에서 성능 저하\n- net.core.wmem_max를 너무 작게 설정: TCP 송신 버퍼가 부족하여 전송 속도 제한, 대용량 파일 전송 시 병목 발생',
      functions: [], 
      position: { x: 200, y: -50 } 
    },
    { 
      id: 'opt-inet', 
      label: 'CONFIG_INET', 
      level: 'KERNEL_OPTION', 
      desc: 'TCP/IP 지원',
      detailedDesc: 'TCP/IP 프로토콜 스택을 활성화합니다. IPv4 네트워킹, TCP, UDP, ICMP 등의 프로토콜을 사용하려면 필수입니다. 이 옵션이 없으면 IP 기반 네트워킹이 불가능합니다.\n\n관련 sysctl: net.ipv4.*\n주요 sysctl 및 Ubuntu 24.04 기본값:\n- net.ipv4.ip_forward = 0 (IP 포워딩 비활성화)\n- net.ipv4.tcp_rmem = 4096 131072 6291456 (TCP 수신 버퍼: min default max)\n- net.ipv4.tcp_wmem = 4096 16384 4194304 (TCP 송신 버퍼: min default max)\n- net.ipv4.tcp_congestion_control = cubic (TCP 혼잡 제어 알고리즘)\n- net.ipv4.tcp_syncookies = 1 (SYN flood 방어 활성화)\n- net.ipv4.conf.all.forwarding = 0 (모든 인터페이스 포워딩 비활성화)\n\n값 변경 시 발생할 수 있는 사례:\n- net.ipv4.ip_forward = 1로 변경: 시스템이 라우터 역할을 하게 되어 다른 네트워크 간 패킷을 전달. 보안상 위험할 수 있으므로 방화벽 설정 필요\n- net.ipv4.tcp_rmem을 너무 작게 설정(예: 4096 8192 16384): 고속 네트워크에서 TCP 수신 버퍼 부족으로 인한 성능 저하, 대역폭 활용도 감소, 패킷 재전송 증가\n- net.ipv4.tcp_rmem의 max 값을 초과하는 트래픽: 버퍼 오버플로우로 인한 패킷 손실, TCP 흐름 제어로 인한 전송 속도 제한\n- net.ipv4.tcp_wmem을 너무 작게 설정: 대용량 파일 전송 시 병목 발생, 전송 속도 저하\n- net.ipv4.tcp_syncookies = 0으로 변경: SYN flood 공격에 취약해짐, 많은 SYN 패킷으로 인한 서비스 거부 가능',
      functions: [], 
      position: { x: 400, y: -50 } 
    },
    { 
      id: 'opt-ipv6', 
      label: 'CONFIG_IPV6', 
      level: 'KERNEL_OPTION', 
      desc: 'IPv6 지원',
      detailedDesc: 'IPv6 프로토콜 스택을 활성화합니다. IPv6 주소, 라우팅, Neighbor Discovery 등을 지원합니다. IPv6 네트워킹을 사용하려면 필수입니다.\n\n관련 sysctl: net.ipv6.*\n주요 sysctl 및 Ubuntu 24.04 기본값:\n- net.ipv6.conf.all.forwarding = 0 (IPv6 포워딩 비활성화)\n- net.ipv6.conf.all.disable_ipv6 = 0 (IPv6 활성화)\n- net.ipv6.conf.default.disable_ipv6 = 0 (기본 인터페이스 IPv6 활성화)\n- net.ipv6.ip_nonlocal_bind = 0 (비로컬 바인딩 비활성화)\n- net.ipv6.conf.all.accept_ra = 1 (Router Advertisement 수신 허용)\n\n값 변경 시 발생할 수 있는 사례:\n- net.ipv6.conf.all.forwarding = 1로 변경: IPv6 라우터로 동작, 다른 IPv6 네트워크 간 패킷 전달 가능. 보안 설정 필요\n- net.ipv6.conf.all.disable_ipv6 = 1로 변경: IPv6 기능 완전 비활성화, IPv6 주소 할당 불가, IPv6 서비스 접근 불가\n- net.ipv6.conf.all.accept_ra = 0으로 변경: Router Advertisement 수신 불가, 자동 IPv6 주소 구성 불가, 수동 설정 필요',
      functions: [], 
      position: { x: 600, y: -50 } 
    },
    { 
      id: 'opt-netfilter', 
      label: 'CONFIG_NETFILTER', 
      level: 'KERNEL_OPTION', 
      desc: 'Netfilter 프레임워크',
      detailedDesc: 'Netfilter 프레임워크를 활성화합니다. iptables, nftables, 패킷 필터링, NAT 등의 기능을 사용하려면 필수입니다. 방화벽과 NAT 기능의 기반이 됩니다.\n\n관련 sysctl: net.netfilter.*\n주요 sysctl 및 Ubuntu 24.04 기본값:\n- net.netfilter.nf_log_all_netns = 0 (모든 네임스페이스 로깅 비활성화)\n- net.netfilter.nf_conntrack_max = 262144 (연결 추적 최대값, CONNTRACK 활성화 시)\n- net.netfilter.nf_conntrack_tcp_timeout_established = 432000 (TCP ESTABLISHED 타임아웃, 초)\n\n값 변경 시 발생할 수 있는 사례:\n- net.netfilter.nf_log_all_netns = 1로 변경: 모든 네트워크 네임스페이스에서 로깅 활성화, 디버깅 용이하나 로그 증가로 인한 성능 저하 가능\n- net.netfilter.nf_conntrack_max를 너무 작게 설정: 많은 연결이 있는 서버에서 연결 추적 테이블 오버플로우, 새로운 연결 거부, "nf_conntrack: table full" 에러 발생',
      functions: [], 
      position: { x: 800, y: -50 } 
    },
    { 
      id: 'opt-nf-conntrack', 
      label: 'CONFIG_NF_CONNTRACK', 
      level: 'KERNEL_OPTION', 
      desc: '연결 추적',
      detailedDesc: 'Netfilter 연결 추적(Connection Tracking) 기능을 활성화합니다. 상태 기반 방화벽, NAT의 연결 추적 등을 지원합니다. iptables의 -m state, -m conntrack 모듈이 필요로 합니다.\n\n관련 sysctl: net.netfilter.nf_conntrack.*\n주요 sysctl 및 Ubuntu 24.04 기본값:\n- net.netfilter.nf_conntrack_max = 262144 (최대 연결 추적 수)\n- net.netfilter.nf_conntrack_tcp_timeout_established = 432000 (TCP ESTABLISHED 타임아웃, 초)\n- net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120 (TCP TIME_WAIT 타임아웃, 초)\n- net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60 (TCP CLOSE_WAIT 타임아웃, 초)\n- net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120 (TCP FIN_WAIT 타임아웃, 초)\n\n값 변경 시 발생할 수 있는 사례:\n- net.netfilter.nf_conntrack_max를 너무 작게 설정(예: 65536): 고부하 서버에서 연결 추적 테이블 포화, 새로운 연결 거부, "nf_conntrack: table full, dropping packet" 에러 발생\n- net.netfilter.nf_conntrack_tcp_timeout_established를 너무 길게 설정(예: 864000): 메모리 사용량 증가, 오래된 연결이 테이블에 남아있어 리소스 낭비\n- net.netfilter.nf_conntrack_tcp_timeout_established를 너무 짧게 설정(예: 3600): 활성 연결이 조기에 타임아웃되어 연결 끊김, 사용자 경험 저하',
      functions: [], 
      position: { x: 1000, y: -50 } 
    },
    { 
      id: 'opt-nf-nat', 
      label: 'CONFIG_NF_NAT', 
      level: 'KERNEL_OPTION', 
      desc: 'NAT 지원',
      detailedDesc: 'Netfilter NAT(Network Address Translation) 기능을 활성화합니다. SNAT, DNAT, MASQUERADE 등의 NAT 기능을 사용하려면 필수입니다.\n\n관련 sysctl: net.netfilter.nf_nat.*, net.ipv4.ip_forward\n주요 sysctl 및 Ubuntu 24.04 기본값:\n- net.netfilter.nf_nat_max = 262144 (NAT 최대 연결 수)\n- net.ipv4.ip_forward = 0 (IP 포워딩 비활성화, NAT 사용 시 1로 설정 필요)\n- net.ipv4.conf.all.forwarding = 0 (모든 인터페이스 포워딩 비활성화)\n- net.ipv4.conf.default.forwarding = 0 (기본 포워딩 비활성화)\n\n값 변경 시 발생할 수 있는 사례:\n- net.ipv4.ip_forward = 1로 변경: 시스템이 라우터로 동작, NAT 게이트웨이 구축 가능. 하지만 보안상 위험하므로 방화벽 규칙 필수. 내부 네트워크와 외부 네트워크 간 패킷 전달 가능\n- net.netfilter.nf_nat_max를 너무 작게 설정: 많은 NAT 연결이 있는 환경에서 NAT 테이블 포화, 새로운 NAT 연결 실패, "nf_nat: table full" 에러 발생\n- NAT 사용 시 ip_forward를 1로 설정하지 않으면: NAT 규칙이 있어도 패킷이 전달되지 않음, 내부에서 외부로의 통신 불가',
      functions: [], 
      position: { x: 1200, y: -50 } 
    },
    { 
      id: 'opt-xdp', 
      label: 'CONFIG_XDP_SOCKETS', 
      level: 'KERNEL_OPTION', 
      desc: 'XDP 소켓',
      detailedDesc: 'XDP(eXpress Data Path) 소켓 지원을 활성화합니다. XDP 프로그램을 사용하여 드라이버 레벨에서 고속 패킷 처리를 가능하게 합니다.\n\n관련 sysctl: 없음 (컴파일 타임 옵션)\n참고: XDP는 주로 eBPF 프로그램을 통해 제어되며, sysctl로 직접 제어되지 않습니다. XDP 프로그램은 bpf() 시스템 콜을 통해 로드됩니다. XDP 소켓은 AF_XDP 주소 패밀리를 사용합니다.\n\n사용 시나리오 및 주의사항:\n- XDP 프로그램을 잘못 작성하면: 패킷이 드롭되어 네트워크 연결 실패, 시스템 리소스 고갈 가능\n- XDP DROP 액션 사용 시: 드라이버 레벨에서 패킷이 즉시 폐기되어 Netfilter보다 빠르지만, 모든 패킷이 차단될 수 있음\n- XDP REDIRECT 사용 시: 패킷을 다른 인터페이스로 리다이렉트하여 로드 밸런싱 가능, 하지만 잘못된 설정 시 패킷 루프 발생 가능\n- XDP 활성화 시: 매우 빠른 패킷 처리 가능(마이크로초 단위), DDoS 방어에 효과적. 하지만 CPU 사용량 증가 가능',
      functions: [], 
      position: { x: 200, y: 50 } 
    },
    { 
      id: 'opt-bpf', 
      label: 'CONFIG_BPF_SYSCALL', 
      level: 'KERNEL_OPTION', 
      desc: 'eBPF 시스템 콜',
      detailedDesc: 'eBPF(extended Berkeley Packet Filter) 시스템 콜을 활성화합니다. XDP, TC, kprobe, uprobe 등에서 eBPF 프로그램을 사용하려면 필수입니다.\n\n관련 sysctl: kernel.unprivileged_bpf_disabled\nUbuntu 24.04 기본값:\n- kernel.unprivileged_bpf_disabled = 1 (비특권 사용자 eBPF 비활성화, 보안상 권장)\n\n값 변경 시 발생할 수 있는 사례:\n- kernel.unprivileged_bpf_disabled = 0으로 변경: 비특권 사용자도 eBPF 프로그램 로드 가능, 보안 위험 증가. 악의적인 eBPF 프로그램으로 인한 시스템 공격 가능, 권한 상승 공격 위험\n- eBPF 프로그램을 잘못 작성하면: 무한 루프로 인한 커널 패닉, 시스템 리소스 고갈, 네트워크 성능 저하\n- eBPF 활성화 시: 강력한 네트워크 모니터링 및 제어 가능, XDP/TC에서 고성능 패킷 처리. 하지만 잘못된 프로그램은 시스템 안정성에 위험',
      functions: [], 
      position: { x: 400, y: 50 } 
    },
    { 
      id: 'opt-gro', 
      label: 'CONFIG_GRO', 
      level: 'KERNEL_OPTION', 
      desc: 'GRO (Generic Receive Offload)',
      detailedDesc: 'GRO(Generic Receive Offload) 기능을 활성화합니다. 여러 작은 패킷을 하나의 큰 패킷으로 합쳐서 처리하여 CPU 부하를 줄입니다. NAPI와 함께 작동합니다.\n\n관련 sysctl: net.core.gro_enabled\nUbuntu 24.04 기본값:\n- net.core.gro_enabled = 1 (GRO 활성화)\n\n값 변경 시 발생할 수 있는 사례:\n- net.core.gro_enabled = 0으로 변경: GRO 비활성화, 작은 패킷을 개별 처리하여 CPU 사용량 증가, 고속 네트워크에서 성능 저하. 특히 10Gbps 이상 네트워크에서 심각한 성능 저하 발생\n- GRO 활성화 시: CPU 효율성 향상, 인터럽트 수 감소, 처리량 증가. 하지만 일부 특수한 네트워크 애플리케이션에서는 패킷 병합으로 인한 문제 발생 가능',
      functions: [], 
      position: { x: 600, y: 50 } 
    },
    { 
      id: 'opt-gso', 
      label: 'CONFIG_GSO', 
      level: 'KERNEL_OPTION', 
      desc: 'GSO (Generic Segmentation Offload)',
      detailedDesc: 'GSO(Generic Segmentation Offload) 기능을 활성화합니다. 큰 패킷을 여러 작은 패킷으로 분할하는 작업을 하드웨어나 드라이버로 오프로드하여 CPU 부하를 줄입니다.\n\n관련 sysctl: net.core.gso_enabled\nUbuntu 24.04 기본값:\n- net.core.gso_enabled = 1 (GSO 활성화)\n\n값 변경 시 발생할 수 있는 사례:\n- net.core.gso_enabled = 0으로 변경: GSO 비활성화, 큰 패킷을 커널에서 분할하여 CPU 사용량 증가, 대용량 데이터 전송 시 성능 저하. 특히 고속 네트워크에서 전송 속도 제한\n- GSO 활성화 시: CPU 효율성 향상, 하드웨어 오프로드로 인한 성능 향상. 하지만 일부 네트워크 장비와의 호환성 문제 발생 가능',
      functions: [], 
      position: { x: 800, y: 50 } 
    },
    { 
      id: 'opt-net-sched', 
      label: 'CONFIG_NET_SCHED', 
      level: 'KERNEL_OPTION', 
      desc: '트래픽 제어',
      detailedDesc: '네트워크 트래픽 제어(Traffic Control) 기능을 활성화합니다. qdisc, tc 명령어, 트래픽 shaping, policing 등을 사용하려면 필수입니다.\n\n관련 sysctl: net.core.default_qdisc, net.core.netdev_max_backlog, net.core.netdev_budget\n주요 sysctl 및 Ubuntu 24.04 기본값:\n- net.core.default_qdisc = fq (기본 큐잉 규율)\n- net.core.netdev_max_backlog = 1000 (네트워크 장치 백로그 최대값)\n- net.core.netdev_budget = 300 (NAPI 폴링 예산)\n- net.core.netdev_budget_usecs = 2000 (NAPI 폴링 예산 시간, 마이크로초)\n\n값 변경 시 발생할 수 있는 사례:\n- net.core.netdev_max_backlog를 너무 작게 설정(예: 100): 고속 네트워크에서 패킷 드롭 발생, "netdev_max_backlog exceeded" 에러, 네트워크 성능 저하\n- net.core.netdev_max_backlog를 너무 크게 설정(예: 10000): 메모리 사용량 증가, 지연 시간 증가 가능\n- net.core.netdev_budget를 너무 작게 설정: NAPI 폴링이 빨리 종료되어 패킷 처리 지연, CPU 효율성 저하\n- net.core.default_qdisc를 pfifo_fast로 변경: 단순 FIFO 큐, 공정성 없는 스케줄링으로 인한 공정성 문제 가능',
      functions: [], 
      position: { x: 1000, y: 50 } 
    },
    { 
      id: 'opt-tcp-cong', 
      label: 'CONFIG_TCP_CONG_ADVANCED', 
      level: 'KERNEL_OPTION', 
      desc: 'TCP 혼잡 제어',
      detailedDesc: '고급 TCP 혼잡 제어 알고리즘을 활성화합니다. CUBIC, BBR, Reno, Vegas 등 다양한 혼잡 제어 알고리즘을 선택할 수 있습니다.\n\n관련 sysctl: net.ipv4.tcp_congestion_control\nUbuntu 24.04 기본값:\n- net.ipv4.tcp_congestion_control = cubic (CUBIC 알고리즘 사용)\n\n사용 가능한 알고리즘: cubic, bbr, reno, vegas, westwood, htcp 등\n참고: 사용 가능한 알고리즘 목록은 /proc/sys/net/ipv4/tcp_available_congestion_control에서 확인할 수 있습니다.\n\n값 변경 시 발생할 수 있는 사례:\n- net.ipv4.tcp_congestion_control = bbr로 변경: Google의 BBR 알고리즘 사용, 고속 네트워크에서 더 높은 처리량과 낮은 지연 시간 제공. 하지만 일부 네트워크 환경에서는 공정성 문제 발생 가능\n- net.ipv4.tcp_congestion_control = reno로 변경: 전통적인 Reno 알고리즘, 안정적이지만 고속 네트워크에서 성능이 CUBIC보다 낮을 수 있음\n- BBR 사용 시: 대역폭 활용도 향상, 특히 고속 장거리 네트워크에서 효과적. 하지만 네트워크 혼잡 시 다른 연결과의 공정성 문제 가능',
      functions: [], 
      position: { x: 1200, y: 50 } 
    },
    { 
      id: 'opt-ip-route-multipath', 
      label: 'CONFIG_IP_ROUTE_MULTIPATH', 
      level: 'KERNEL_OPTION', 
      desc: '다중 경로 라우팅',
      detailedDesc: '다중 경로 라우팅(Multipath Routing) 지원을 활성화합니다. 여러 경로를 통해 트래픽을 분산시킬 수 있습니다.\n\n관련 sysctl: net.ipv4.fib_multipath.*\n주요 sysctl 및 Ubuntu 24.04 기본값:\n- net.ipv4.fib_multipath_hash_policy = 0 (해시 정책: 0=layer3, 1=layer4)\n- net.ipv4.fib_multipath_use_neigh = 0 (이웃 정보 사용 비활성화)\n- net.ipv4.fib_multipath_hash_fields = 7 (해시 필드: source IP, dest IP, source port, dest port)\n\n값 변경 시 발생할 수 있는 사례:\n- net.ipv4.fib_multipath_hash_policy = 1로 변경: Layer 4 해시 사용, 같은 연결의 패킷이 같은 경로를 사용하여 순서 보장. 하지만 트래픽 분산이 덜 균등할 수 있음\n- 다중 경로 라우팅 활성화 시: 여러 네트워크 경로를 통해 트래픽 분산, 대역폭 활용도 향상, 경로 장애 시 자동 전환. 하지만 패킷 순서 문제 발생 가능',
      functions: [], 
      position: { x: 1400, y: -50 } 
    },
    { 
      id: 'opt-ip-advanced-router', 
      label: 'CONFIG_IP_ADVANCED_ROUTER', 
      level: 'KERNEL_OPTION', 
      desc: '고급 라우팅',
      detailedDesc: '고급 라우팅 기능을 활성화합니다. 다중 라우팅 테이블, 정책 기반 라우팅, 라우팅 규칙 등을 사용할 수 있습니다.\n\n관련 sysctl: net.ipv4.ip_forward, net.ipv4.conf.*.forwarding, net.ipv4.conf.*.rp_filter\n주요 sysctl 및 Ubuntu 24.04 기본값:\n- net.ipv4.ip_forward = 0 (IP 포워딩 비활성화)\n- net.ipv4.conf.all.forwarding = 0 (모든 인터페이스 포워딩 비활성화)\n- net.ipv4.conf.default.forwarding = 0 (기본 포워딩 비활성화)\n- net.ipv4.conf.all.rp_filter = 1 (Reverse Path Filtering 활성화)\n- net.ipv4.conf.default.rp_filter = 1 (기본 Reverse Path Filtering 활성화)\n\n값 변경 시 발생할 수 있는 사례:\n- net.ipv4.ip_forward = 1로 변경: 시스템이 라우터로 동작, 다른 네트워크 간 패킷 전달 가능. 보안상 위험하므로 방화벽 규칙 필수 설정 필요\n- net.ipv4.conf.all.rp_filter = 0으로 변경: Reverse Path Filtering 비활성화, 스푸핑된 패킷이 통과할 수 있어 보안 위험 증가. 하지만 비대칭 라우팅 환경에서는 필요할 수 있음\n- rp_filter = 2 (loose mode): 더 느슨한 검사, 비대칭 라우팅 환경에서 유용하나 보안은 약간 약화',
      functions: [], 
      position: { x: 1400, y: 50 } 
    },
    { 
      id: 'opt-tcp-md5', 
      label: 'CONFIG_TCP_MD5SIG', 
      level: 'KERNEL_OPTION', 
      desc: 'TCP MD5 시그니처',
      detailedDesc: 'TCP MD5 시그니처 옵션을 활성화합니다. BGP 등의 프로토콜에서 TCP 연결의 무결성을 보장하기 위해 사용됩니다.\n\n관련 sysctl: net.ipv4.tcp_md5sig_enabled (커널 6.0+)\nUbuntu 24.04 기본값:\n- net.ipv4.tcp_md5sig_enabled = 0 (MD5 시그니처 비활성화, 보안상 권장)\n\n값 변경 시 발생할 수 있는 사례:\n- net.ipv4.tcp_md5sig_enabled = 1로 변경: TCP MD5 시그니처 활성화, BGP 세션 보호 가능. 하지만 MD5는 암호학적으로 취약하여 중간자 공격에 취약, 현대적인 시스템에서는 권장되지 않음\n- MD5 시그니처 사용 시: BGP 라우터 간 인증 가능, 하지만 키 관리 복잡도 증가, MD5 해시 충돌 공격 위험\n- 보안 권장사항: IPsec, TLS 등 더 안전한 프로토콜 사용 권장. BGP의 경우 TCP-AO(TCP Authentication Option) 사용 권장',
      functions: [], 
      position: { x: 1600, y: 0 } 
    }
  ],
  edges: [
    // RX 경로
    { source: 'nic-rx', target: 'nic-rx-ring' },
    { source: 'nic-rx-ring', target: 'driver-rx' },
    { source: 'driver-rx', target: 'napi-rx' },
    { source: 'driver-rx', target: 'xdp-rx' },
    { source: 'xdp-rx', target: 'skb-rx' },
    { source: 'napi-rx', target: 'skb-rx' },
    { source: 'skb-rx', target: 'netfilter-rx' },
    { source: 'netfilter-rx', target: 'routing-rx' },
    { source: 'routing-rx', target: 'socket-rx' },
    { source: 'socket-rx', target: 'tcp-rx-buffer' },
    { source: 'socket-rx', target: 'socket-rx-queue' },
    { source: 'socket-rx-queue', target: 'user-rx' },
    
    // Netfilter Hook 연결 (RX)
    { source: 'netfilter-rx', target: 'nf:prerouting' },
    { source: 'nf:prerouting', target: 'routing-rx' },
    { source: 'routing-rx', target: 'nf:input' },
    { source: 'routing-rx', target: 'nf:forward' },
    { source: 'nf:input', target: 'socket-rx' },
    
    // TX 경로
    { source: 'user-tx', target: 'socket-tx-queue' },
    { source: 'socket-tx-queue', target: 'socket-tx' },
    { source: 'socket-tx', target: 'tcp-tx' },
    { source: 'socket-tx', target: 'tcp-tx-buffer' },
    { source: 'tcp-tx-buffer', target: 'tcp-tx' },
    { source: 'tcp-tx', target: 'netfilter-tx-out' },
    { source: 'netfilter-tx-out', target: 'routing-tx' },
    { source: 'routing-tx', target: 'netfilter-tx-post' },
    { source: 'netfilter-tx-post', target: 'tc-tx' },
    { source: 'tc-tx', target: 'qdisc-queue' },
    { source: 'qdisc-queue', target: 'driver-tx' },
    { source: 'driver-tx', target: 'nic-tx-ring' },
    { source: 'nic-tx-ring', target: 'nic-tx' },
    
    // Netfilter Hook 연결 (TX)
    { source: 'netfilter-tx-out', target: 'nf:output' },
    { source: 'nf:output', target: 'routing-tx' },
    { source: 'routing-tx', target: 'nf:postrouting' },
    { source: 'nf:postrouting', target: 'tc-tx' },
    
    // 패킷 드롭 및 RST 연결
    { source: 'nic-rx-ring', target: 'drop-rx-ring' },
    { source: 'napi-rx', target: 'drop-napi' },
    { source: 'xdp-rx', target: 'drop-xdp' },
    { source: 'netfilter-rx', target: 'drop-netfilter' },
    { source: 'nf:input', target: 'drop-netfilter' },
    { source: 'nf:forward', target: 'drop-netfilter' },
    { source: 'nf:output', target: 'drop-netfilter' },
    { source: 'routing-rx', target: 'drop-routing' },
    { source: 'routing-tx', target: 'drop-routing' },
    { source: 'socket-rx', target: 'drop-tcp' },
    { source: 'socket-rx', target: 'rst-tcp' },
    { source: 'qdisc-queue', target: 'drop-qdisc' },
    
    // 커널 옵션 연결
    { source: 'opt-net', target: 'driver-rx' },
    { source: 'opt-net', target: 'driver-tx' },
    { source: 'opt-inet', target: 'socket-rx' },
    { source: 'opt-inet', target: 'socket-tx' },
    { source: 'opt-inet', target: 'routing-rx' },
    { source: 'opt-inet', target: 'routing-tx' },
    { source: 'opt-ipv6', target: 'routing-rx' },
    { source: 'opt-ipv6', target: 'routing-tx' },
    { source: 'opt-netfilter', target: 'netfilter-rx' },
    { source: 'opt-netfilter', target: 'netfilter-tx-out' },
    { source: 'opt-netfilter', target: 'netfilter-tx-post' },
    { source: 'opt-nf-conntrack', target: 'nf:prerouting' },
    { source: 'opt-nf-conntrack', target: 'nf:input' },
    { source: 'opt-nf-conntrack', target: 'nf:output' },
    { source: 'opt-nf-nat', target: 'nf:prerouting' },
    { source: 'opt-nf-nat', target: 'nf:postrouting' },
    { source: 'opt-xdp', target: 'xdp-rx' },
    { source: 'opt-bpf', target: 'xdp-rx' },
    { source: 'opt-bpf', target: 'tc-tx' },
    { source: 'opt-gro', target: 'napi-rx' },
    { source: 'opt-gso', target: 'tcp-tx' },
    { source: 'opt-net-sched', target: 'tc-tx' },
    { source: 'opt-tcp-cong', target: 'socket-rx' },
    { source: 'opt-tcp-cong', target: 'socket-tx' },
    { source: 'opt-ip-route-multipath', target: 'routing-rx' },
    { source: 'opt-ip-route-multipath', target: 'routing-tx' },
    { source: 'opt-ip-advanced-router', target: 'routing-rx' },
    { source: 'opt-ip-advanced-router', target: 'routing-tx' },
    { source: 'opt-tcp-md5', target: 'socket-rx' },
    { source: 'opt-tcp-md5', target: 'socket-tx' }
  ]
};

// Cytoscape 인스턴스 생성
const cy = cytoscape({
  container: document.getElementById('cy'),
  
  wheelSensitivity: 0.15,
  minZoom: 0.2,
  maxZoom: 4,
  panningEnabled: true,
  zoomingEnabled: true,
  
  style: [
    {
      selector: 'node',
      style: {
        'label': 'data(label)',
        'text-valign': 'center',
        'text-halign': 'center',
        'color': '#fff',
        'background-color': 'data(color)',
        'width': 140,
        'height': 60,
        'font-size': 13,
        'font-weight': 'bold',
        'shape': 'roundrectangle',
        'border-width': 2,
        'border-color': '#fff',
        'text-wrap': 'wrap',
        'text-max-width': 130
      }
    },
    {
      selector: 'edge',
      style: {
        'width': 3,
        'line-color': '#60a5fa',
        'target-arrow-color': '#60a5fa',
        'target-arrow-shape': 'triangle',
        'curve-style': 'bezier',
        'opacity': 0.7
      }
    },
    {
      selector: 'edge[sourceLevel = "KERNEL_OPTION"]',
      style: {
        'line-color': LEVEL_COLORS.KERNEL_OPTION,
        'target-arrow-color': LEVEL_COLORS.KERNEL_OPTION,
        'line-style': 'dashed'
      }
    },
    {
      selector: 'node[level = "HARDWARE"]',
      style: {
        'background-color': LEVEL_COLORS.HARDWARE
      }
    },
    {
      selector: 'node[level = "DRIVER"]',
      style: {
        'background-color': LEVEL_COLORS.DRIVER
      }
    },
    {
      selector: 'node[level = "KERNEL_LOW"]',
      style: {
        'background-color': LEVEL_COLORS.KERNEL_LOW
      }
    },
    {
      selector: 'node[level = "NETFILTER"]',
      style: {
        'background-color': LEVEL_COLORS.NETFILTER
      }
    },
    {
      selector: 'node[level = "ROUTING"]',
      style: {
        'background-color': LEVEL_COLORS.ROUTING
      }
    },
    {
      selector: 'node[level = "SOCKET"]',
      style: {
        'background-color': LEVEL_COLORS.SOCKET
      }
    },
    {
      selector: 'node[level = "XDP"]',
      style: {
        'background-color': LEVEL_COLORS.XDP
      }
    },
    {
      selector: 'node[level = "TC"]',
      style: {
        'background-color': LEVEL_COLORS.TC
      }
    },
    {
      selector: 'node[level = "BUFFER"]',
      style: {
        'background-color': LEVEL_COLORS.BUFFER
      }
    },
    {
      selector: 'node[level = "USER"]',
      style: {
        'background-color': LEVEL_COLORS.USER
      }
    },
    {
      selector: 'node[level = "KERNEL_OPTION"]',
      style: {
        'background-color': LEVEL_COLORS.KERNEL_OPTION,
        'width': 180,
        'height': 50,
        'font-size': 11
      }
    },
    {
      selector: 'node[level = "DROP"]',
      style: {
        'background-color': LEVEL_COLORS.DROP,
        'shape': 'diamond',
        'width': 120,
        'height': 120
      }
    },
    {
      selector: 'node[level = "RST"]',
      style: {
        'background-color': LEVEL_COLORS.RST,
        'shape': 'diamond',
        'width': 120,
        'height': 120
      }
    }
  ],
  
  elements: {
    nodes: networkData.nodes.map(node => ({
      data: {
        id: node.id,
        label: node.label,
        level: node.level,
        desc: node.desc,
        detailedDesc: node.detailedDesc || '',
        functions: node.functions || [],
        color: LEVEL_COLORS[node.level] || '#666'
      },
      position: node.position,
      classes: node.parent ? 'detail-node' : 'main-node'
    })),
    edges: networkData.edges.map(edge => {
      const sourceNode = networkData.nodes.find(n => n.id === edge.source);
      return {
        data: {
          source: edge.source,
          target: edge.target,
          sourceLevel: sourceNode ? sourceNode.level : null
        }
      };
    })
  },
  
  layout: {
    name: 'preset'
  }
});

// 정보 패널 업데이트
const info = document.getElementById('info');
const zoomLevelDisplay = document.getElementById('zoom-level');

function updateInfoPanel(node) {
  const level = node.data('level');
  const levelNames = {
    'HARDWARE': '하드웨어',
    'DRIVER': '드라이버',
    'KERNEL_LOW': '커널 (저수준)',
    'NETFILTER': 'Netfilter',
    'ROUTING': '라우팅',
    'SOCKET': '소켓',
    'XDP': 'XDP',
    'TC': '트래픽 제어',
    'BUFFER': '버퍼',
    'USER': '사용자 공간',
    'KERNEL_OPTION': '커널 옵션',
    'DROP': '패킷 드롭',
    'RST': 'TCP RST'
  };
  
  let html = `
    <h3>${node.data('label')}</h3>
    <p><span class="level-badge" style="background: ${node.data('color')}; color: #fff;">${levelNames[level] || level}</span></p>
    <p class="desc"><strong>${node.data('desc')}</strong></p>
  `;
  
  const detailedDesc = node.data('detailedDesc');
  if (detailedDesc) {
    // 줄바꿈(\n)을 <br>로 변환
    const formattedDesc = detailedDesc.replace(/\n/g, '<br>');
    html += `
      <div style="margin-top: 16px;">
        <p style="color: #9ca3af; line-height: 1.8; font-size: 14px;">${formattedDesc}</p>
      </div>
    `;
  }
  
  const functions = node.data('functions');
  if (functions && functions.length > 0) {
    html += `
      <div style="margin-top: 16px;">
        <p><strong style="color: #7dd3fc;">주요 함수:</strong></p>
        <ul class="function-list">
          ${functions.map(fn => `<li>${fn}</li>`).join('')}
        </ul>
      </div>
    `;
  }
  
  info.innerHTML = html;
}

// 노드 클릭 이벤트
cy.on('tap', 'node', evt => {
  const node = evt.target;
  updateInfoPanel(node);
  
  // 클릭된 노드와 연결된 모든 노드 찾기 (neighborhood)
  const connectedNodes = node.neighborhood('node');
  const highlightedNodes = connectedNodes.add(node); // 연결된 노드 + 클릭된 노드
  
  // 모든 노드 처리
  cy.nodes().forEach(n => {
    if (highlightedNodes.has(n)) {
      // 강조된 노드: 붉은 윤곽선
      if (n === node) {
        n.style({
          'border-width': 5,
          'border-color': '#ef4444',
          'background-color': n.data('color'),
          'opacity': 1
        });
      } else {
        n.style({
          'border-width': 4,
          'border-color': '#f87171',
          'background-color': n.data('color'),
          'opacity': 1
        });
      }
    } else {
      // 강조되지 않은 노드: 진회색
      n.style({
        'border-width': 2,
        'border-color': '#fff',
        'background-color': '#4b5563',
        'opacity': 0.5
      });
    }
  });
  
  // 모든 엣지 처리
  cy.edges().forEach(e => {
    const source = e.source();
    const target = e.target();
    const isHighlighted = highlightedNodes.has(source) || highlightedNodes.has(target);
    
    if (isHighlighted) {
      // 강조된 엣지: 원래 색상 유지
      const sourceLevel = e.data('sourceLevel');
      if (sourceLevel === 'KERNEL_OPTION') {
        e.style({
          'line-color': LEVEL_COLORS.KERNEL_OPTION,
          'target-arrow-color': LEVEL_COLORS.KERNEL_OPTION,
          'opacity': 0.7
        });
      } else {
        e.style({
          'line-color': '#60a5fa',
          'target-arrow-color': '#60a5fa',
          'opacity': 0.7
        });
      }
    } else {
      // 강조되지 않은 엣지: 진회색
      e.style({
        'line-color': '#6b7280',
        'target-arrow-color': '#6b7280',
        'opacity': 0.3
      });
    }
  });
});

// 배경 클릭 시 원래 색상으로 복원
cy.on('tap', evt => {
  if (evt.target === cy) {
    // 모든 노드를 원래 색상으로 복원
    cy.nodes().forEach(n => {
      n.style({
        'border-width': 2,
        'border-color': '#fff',
        'background-color': n.data('color'),
        'opacity': 1
      });
    });
    
    // 모든 엣지를 원래 색상으로 복원
    cy.edges().forEach(e => {
      const sourceLevel = e.data('sourceLevel');
      if (sourceLevel === 'KERNEL_OPTION') {
        e.style({
          'line-color': LEVEL_COLORS.KERNEL_OPTION,
          'target-arrow-color': LEVEL_COLORS.KERNEL_OPTION,
          'opacity': 0.7
        });
      } else {
        e.style({
          'line-color': '#60a5fa',
          'target-arrow-color': '#60a5fa',
          'opacity': 0.7
        });
      }
    });
  }
});

// Zoom 이벤트 핸들러
cy.on('zoom', () => {
  const z = cy.zoom();
  zoomLevelDisplay.textContent = `Zoom: ${z.toFixed(2)}x`;
  
  // 모든 노드는 항상 표시됨 (줌 레벨과 무관)
});

// 키보드 이벤트
document.addEventListener('keydown', e => {
  const pan = cy.pan();
  const step = 80;
  const zoomStep = 0.2;

  switch (e.key) {
    case 'ArrowUp':
      cy.pan({ x: pan.x, y: pan.y + step });
      break;
    case 'ArrowDown':
      cy.pan({ x: pan.x, y: pan.y - step });
      break;
    case 'ArrowLeft':
      cy.pan({ x: pan.x + step, y: pan.y });
      break;
    case 'ArrowRight':
      cy.pan({ x: pan.x - step, y: pan.y });
      break;
    case '+':
    case '=':
      cy.zoom(cy.zoom() + zoomStep);
      break;
    case '-':
    case '_':
      cy.zoom(cy.zoom() - zoomStep);
      break;
    case 'Escape':
      cy.fit();
      break;
  }
});

// 초기 전체 보기
cy.ready(() => {
  cy.fit(50);
  zoomLevelDisplay.textContent = `Zoom: ${cy.zoom().toFixed(2)}x`;
});

// 범례 추가
const legendHtml = `
  <div class="legend">
    <h3>계층별 색상</h3>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.HARDWARE};"></div>
      <span>하드웨어 (NIC)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.DRIVER};"></div>
      <span>드라이버</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.KERNEL_LOW};"></div>
      <span>커널 저수준 (NAPI, skb)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.XDP};"></div>
      <span>XDP</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.NETFILTER};"></div>
      <span>Netfilter</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.ROUTING};"></div>
      <span>라우팅</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.SOCKET};"></div>
      <span>소켓</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.TC};"></div>
      <span>트래픽 제어 (TC/qdisc)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.BUFFER};"></div>
      <span>버퍼 (Buffer/Queue)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.USER};"></div>
      <span>사용자 공간 (User-space)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.KERNEL_OPTION};"></div>
      <span>커널 옵션 (Kernel Option)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.DROP};"></div>
      <span>패킷 드롭 (Packet Drop)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: ${LEVEL_COLORS.RST};"></div>
      <span>TCP RST</span>
    </div>
  </div>
`;

info.innerHTML += legendHtml;
</script>

</body>
</html>

